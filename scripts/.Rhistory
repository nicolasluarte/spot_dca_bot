2+2
version()
import time
import sys
from pyinput import keyboard
from pynput import keyboard
pip3
from pynput import keyboard
from pynput import keyboard
import sys
import time
import sys
from pynput import keyboard
cite("optim")
cite("optim")
optim
citation("optim")
optim
citation("stats")
# libs ----
pacman::p_load(
tidyverse,
crypto2,
furrr,
fitdistrplus,
mgcv,
patchwork,
extrafont
)
setwd(this.path::here())
palette("Okabe-Ito")
# compute entropy per ID per rel_date per exp_group per exp_phase
binary_entropy <- function(p) {
if (p == 0 || p == 1) {
return(0)
}
return(- (p * log2(p) + (1 - p) * log2(1 - p)))
}
btc_data <- read_rds("../data/1_bitcoin.rds")
daily_entropy <- btc_data %>%
rowwise() %>%
mutate(
mean_daily = mean(c_across(c("open", "high", "low", "close"))),
sd_daily = sd(c_across(c("open", "high", "low", "close")))
) %>%
ungroup() %>%
mutate(
cv_daily = sd_daily / mean_daily,
scaled_ts = scales::rescale(as.numeric(timestamp)),
detrend_close = residuals(lm(log(close) ~ scaled_ts))
)
btc_train_data <- daily_entropy %>%
filter(
scaled_ts <= 0.5
)
btc_test_data <- daily_entropy %>%
filter(
scaled_ts > 0.5
)
fit_g <- fitdist(daily_entropy$cv_daily,
"gamma",
method = "mle")
plot(fit_g)
param_fit_daily <- daily_entropy %>%
mutate(
gamma_fit = pgamma(cv_daily,
shape = fit_g$estimate[1],
rate = fit_g$estimate[2])
)
btc_train_data <- btc_train_data %>%
mutate(
odd_year = lubridate::year(timestamp) %% 2,
gamma_fit = pgamma(cv_daily,
shape = fit_g$estimate[1],
rate = fit_g$estimate[2]),
smooth_gamma = smooth.spline(scaled_ts, gamma_fit, spar = 1)$y,
crit_val = if_else(gamma_fit < 0.1, 1, 0)
)
btc_test_data <- btc_test_data %>%
mutate(
odd_year = lubridate::year(timestamp) %% 2,
gamma_fit = pgamma(cv_daily,
shape = fit_g$estimate[1],
rate = fit_g$estimate[2]),
smooth_gamma = smooth.spline(scaled_ts, gamma_fit, spar = 1)$y,
crit_val = if_else(gamma_fit < 0.1, 1, 0)
)
# train mdl
lm_train <- lm(
data = btc_train_data,
detrend_close ~ smooth_gamma + I(smooth_gamma^3)
)
summary(lm_train)
smooth_trend <- emmeans::emtrends(
lm_train,
specs = ~ smooth_gamma,
var = "smooth_gamma",
at = list(smooth_gamma = seq(0, 1, 0.01))
)
smooth_trend
broom::tidy(smooth_trend, conf.int = TRUE) %>%
ggplot(aes(
smooth_gamma, smooth_gamma.trend
)) +
geom_line() +
geom_ribbon(aes(
ymin = conf.low, ymax = conf.high
), fill = "tan3", alpha = 0.25) +
geom_hline(yintercept = 0, linetype = "dashed") +
geom_vline(xintercept = c(0.3628, 0.6075), linetype = "dashed")
# plot train fit
p1 <- btc_train_data %>%
mutate(
preds = predict(lm_train),
conf.low = predict(lm_train, interval = "prediction")[,2],
conf.high = predict(lm_train, interval = "prediction")[,3]
) %>%
ggplot(aes(
scaled_ts, detrend_close
)) +
geom_line() +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "tan3", alpha = 0.25) +
geom_point(
aes(scaled_ts, preds),
color = "tan3"
) +
geom_hline(yintercept = 0, linetype = "dashed") +
ylim(c(-2, 2))
# plot test fit
p2 <- btc_test_data %>%
mutate(
preds = predict(lm_train, newdata = btc_test_data),
conf.low = predict(lm_train, newdata = btc_test_data, interval = "prediction")[,2],
conf.high = predict(lm_train, newdata = btc_test_data, interval = "prediction")[,3]
) %>%
ggplot(aes(
scaled_ts, detrend_close
)) +
geom_line() +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "tan3", alpha = 0.25) +
geom_point(
aes(scaled_ts, preds),
color = "tan3"
) +
geom_hline(yintercept = 0, linetype = "dashed") +
ylim(c(-2, 2))
p1 + p2
test <- smooth.spline(btc_test_data$scaled_ts, btc_test_data$gamma_fit, spar = 1)
test
coefficients(test)
summary(test)
