}
# compute actual price deviation from previous order
if (price == 0){
price_deviation <- 0
}
else{
price_deviation <- (price - tail(buy_prices, n=1)) / price
}
# make dca order?
if (price_deviation <= price_deviation_target &
dca_counter <= dca_orders_max){
dca_counter <- dca_counter + 1
price_deviation_target <- price_deviation_target *
(price_deviation_multiplier^dca_counter)
DCA_bool <- TRUE
coin_bag <- append(coin_bag, dca_sizes[dca_counter]/price)
buy_prices <- append(buy_prices, price)
outflow <- append(outflow, dca_sizes[dca_counter])
average_buy_price <- sum(outflow)/sum(coin_bag)
}
# take profit
else if ( (price - average_buy_price)/price >= take_profit_target &
i > 1) {
dca_counter <- 0
TP_bool <- TRUE
drawdown_out <- append(drawdown_out, min(drawdown))
drawdown <- 0
realized_profit <- append(realized_profit,
(sum(coin_bag)*price) - sum(outflow)
)
# reset all values
coin_bag <- c()
buy_price <- c()
outflow <- c()
average_buy_price <- 0
# buy ASAP
coin_bag <- append(coin_bag, base_order_size/price)
buy_prices <- append(buy_prices, price)
outflow <- append(outflow, base_order_size)
average_buy_price <- sum(outflow)/sum(coin_bag)
}
# sell all at the end of simulation
# testing NOT selling all at the end of the simulation
if (i == len){
TP_bool <- FALSE
drawdown_out <- append(drawdown_out, min(drawdown))
# update tibble for the last time
headers <-
headers %>%
add_row(
price = price,
TP_bool = TP_bool,
DCA_bool = DCA_bool,
dca_orders_max = dca_orders_max,
coin_bag = tail(coin_bag, n=1),
buy_prices = tail(buy_prices, n=1),
outflow = tail(outflow, n=1),
average_buy_price = tail(average_buy_price, n=1),
realized_profit = tail(realized_profit, n=1),
price_deviation = price_deviation,
dca_counter = dca_counter,
price_deviation_target = price_deviation_target,
step = i
)
# compute end of simulation results
profit_out <- headers %>%
filter(TP_bool == TRUE) %>%
pull(realized_profit) %>%
{sum(.)}
number_of_tp_actions <-
headers %>%
filter(TP_bool == TRUE) %>%
pull(TP_bool) %>%
{length(.)}
cost_tibble <- headers %>%
filter(price != 0, average_buy_price != 0)
price <- cost_tibble %>% pull(price)
average_buy_price <- cost_tibble %>% pull(average_buy_price)
# price and buy price deviations
# consider this as the sum of squared differences
# that is, deviation from the price, but we only care
# for deviation above price
dev <- (average_buy_price - price)
# I take only positives because this are the one we want to reduce
# when average buy price > price
# taking al l leads to unwanted behavior
# take all deviations from price a square them
dev_positive <- dev[dev>0]^2
cost <- sum(dev_positive)
}
# if (i %% 100 == 0){
#     print(paste0("progress: ", round((i/len)*100,2), "%" ))
#     }
}
# the lower the better
return(cost)
}
cost_function2 <- function(
price_series, # a given simulation
base_order_size,
DCA_order_size,
num_of_dca, # this is the percent of max possible
dca_multiplier, # multiply each successive dca order
price_deviation_target, # when to make a dca order
price_deviation_multiplier,
take_profit_target, # when to take profit
days,
len
){
# initialize parameters
tictoc::tic()
days <- days
len <- 1 * days # to simulate every 10 minutes
price_series <- price_series
capital <- 10000
num_of_dca <- num_of_dca
dca_multiplier <- dca_multiplier
price_deviation_target <- price_deviation_target
take_profit_target <- take_profit_target
dca_counter <- 0
dca_orders_max <- 1
average_buy_price <- 0
price_deviation <- 0
drawdown <- 0
drawdown_out <- 0
# simulation parameters
coin_bag <- c(0) # stores bought coins
buy_prices <- c(0) # stores coin buy prices
outflow <- c(0) # stores money spent
realized_profit <- c(0) # stores realized profit
DCA_bool <- FALSE # bool to store event
TP_bool <- FALSE # bool to store event
# create tibble to store simulation variables
headers <- tibble(
price = 0,
TP_bool = FALSE,
DCA_bool = FALSE,
dca_orders_max = 0,
coin_bag = 0,
buy_prices = 0,
outflow = 0,
average_buy_price = 0,
realized_profit = 0,
price_deviation = 0,
dca_counter = 0,
price_deviation_target = price_deviation_target,
step = 0
)
# main simulation loop
for (i in 1:len){
# observe current price
price <- price_series$y[i]
drawdown <- append(drawdown, if_else(average_buy_price != 0,
(price - average_buy_price) / price,
0))
# update headers
headers <-
headers %>%
add_row(
price = price,
TP_bool = TP_bool,
DCA_bool = DCA_bool,
dca_orders_max = dca_orders_max,
coin_bag = tail(coin_bag, n=1),
buy_prices = tail(buy_prices, n=1),
outflow = tail(outflow, n=1),
average_buy_price = tail(average_buy_price, n=1),
realized_profit = tail(realized_profit, n=1),
price_deviation = price_deviation,
dca_counter = dca_counter,
price_deviation_target = price_deviation_target,
step = i
)
# reset events
DCA_bool <- FALSE
TP_bool <- FALSE
# this is the first buy event
if (i == 1){
# check maximum number of DCA orders
dca_sizes <- (DCA_order_size * (dca_multiplier^(0:100)))
dca_depth <- cumsum(DCA_order_size * (dca_multiplier^(0:100)))
available_dca_capital <- capital - base_order_size
max_depth <- max(which(available_dca_capital >= dca_depth))
dca_orders_max <- trunc(max_depth * num_of_dca)
coin_bag <- append(coin_bag, base_order_size/price)
buy_prices <- append(buy_prices, price)
outflow <- append(outflow, base_order_size)
average_buy_price <- sum(outflow)/sum(coin_bag)
}
# compute actual price deviation from previous order
if (price == 0){
price_deviation <- 0
}
else{
price_deviation <- (price - tail(buy_prices, n=1)) / price
}
# make dca order?
if (price_deviation <= price_deviation_target &
dca_counter <= dca_orders_max){
dca_counter <- dca_counter + 1
price_deviation_target <- price_deviation_target *
(price_deviation_multiplier^dca_counter)
DCA_bool <- TRUE
coin_bag <- append(coin_bag, dca_sizes[dca_counter]/price)
buy_prices <- append(buy_prices, price)
outflow <- append(outflow, dca_sizes[dca_counter])
average_buy_price <- sum(outflow)/sum(coin_bag)
}
# take profit
else if ( (price - average_buy_price)/price >= take_profit_target &
i > 1) {
dca_counter <- 0
TP_bool <- TRUE
drawdown_out <- append(drawdown_out, min(drawdown))
drawdown <- 0
realized_profit <- append(realized_profit,
(sum(coin_bag)*price) - sum(outflow)
)
# reset all values
coin_bag <- c()
buy_price <- c()
outflow <- c()
average_buy_price <- 0
# buy ASAP
coin_bag <- append(coin_bag, base_order_size/price)
buy_prices <- append(buy_prices, price)
outflow <- append(outflow, base_order_size)
average_buy_price <- sum(outflow)/sum(coin_bag)
}
# sell all at the end of simulation
if (i == len){
TP_bool <- FALSE
drawdown_out <- append(drawdown_out, min(drawdown))
# update tibble for the last time
headers <-
headers %>%
add_row(
price = price,
TP_bool = TP_bool,
DCA_bool = DCA_bool,
dca_orders_max = dca_orders_max,
coin_bag = tail(coin_bag, n=1),
buy_prices = tail(buy_prices, n=1),
outflow = tail(outflow, n=1),
average_buy_price = tail(average_buy_price, n=1),
realized_profit = tail(realized_profit, n=1),
price_deviation = price_deviation,
dca_counter = dca_counter,
price_deviation_target = price_deviation_target,
step = i
)
# compute end of simulation results
#             profit_out <- headers %>%
#                 filter(TP_bool == TRUE) %>%
#                 pull(realized_profit) %>%
#                 {sum(.)}
#             number_of_tp_actions <-
#                 headers %>%
#                 filter(TP_bool == TRUE) %>%
#                 pull(TP_bool) %>%
#                 {length(.)}
# 	    uvc <- abs(mean(drawdown_out)) + (sd(drawdown_out)*1)
#             cost <- -(profit_out / (uvc/number_of_tp_actions))
}
# if (i %% 100 == 0){
#     print(paste0("progress: ", round((i/len)*100,2), "%" ))
#     }
}
# the lower the better
tictoc::toc()
return(headers)
}
list_of_runs <-
runs %>%
group_by(iteration) %>%
group_split()
sample_runs <-
list_of_runs %>%
{.[sample(c(1:length(list_of_runs)), size = 100, replace = TRUE)]}
sample_runs[[1]]
sample_runs[[2]]
plan(multisession, workers = 8)
sum_cost_function <- function(
theta
){
out <-
# note: this runs are hardcoded, change this in the future
sample_runs %>%
future_imap_dfr(
., function(X, idx){
cost_sim <- cost_function(
price_series = X,
base_order_size = 10000*theta[1],
DCA_order_size = 10000*theta[2],
num_of_dca = 1,
dca_multiplier = theta[3],
price_deviation_target = theta[4],
price_deviation_multiplier = theta[5],
take_profit_target = theta[6],
days = n_days,
len = days
)
return(
tibble(
cost = cost_sim,
idx = idx,
intercept = unique(X$intercept),
poly_1 = unique(X$poly_1),
poly_2 = unique(X$poly_2),
poly_3 = unique(X$poly_3),
mdl_sigma = unique(X$mdl_sigma)
)
)
}
)
return(mean(out$cost))
}
opts <- list(
"algorithm" = "NLOPT_LN_BOBYQA",
"xtol_rel" = 1.0e-04,
"maxeval" = 5000000,
"print_level" = 3
)
print(paste0("Starting optimization for: ", coin))
non_linear_opt0 <-
nloptr(
x0 = c(
0.01, # base order size
0.01, # DCA order size
1, # dca multiplier
-0.01, # price_deviation_target
1, # price deviation multiplier
0.05 # take profit target
),
eval_f = sum_cost_function,
lb = c(0.01, 0.01, 1, -0.1, 1, 0.05),
ub = c(0.25, 0.25, 3, -0.005, 3, 0.1),
opts = opts
)
optimization_out <-
tibble(
solution = non_linear_opt0$solution,
parameters = c(
"base_order_size",
"DCA_order_size",
"dca_multiplier",
"price_deviation_target",
"price_deviation_multiplier",
"take_profit_target"
)
)
sim_optimal <-
sample_runs %>%
future_imap_dfr(
., function(X, idx){
cost_sim <- cost_function2(
price_series = X,
base_order_size = 10000*optimization_out$solution[1],
DCA_order_size = 10000*optimization_out$solution[2],
num_of_dca = 1,
dca_multiplier = optimization_out$solution[3],
price_deviation_target = optimization_out$solution[4],
price_deviation_multiplier = optimization_out$solution[5],
take_profit_target = optimization_out$solution[6],
days = 30,
len = 30*1
) %>%
mutate(
idx = idx
)
}, .progress = TRUE)
r_2 <- sim_optimal %>%
ungroup() %>%
filter(price != 0, average_buy_price != 0, TP_bool==FALSE) %>%
group_by(idx) %>%
mutate(
mean_price = mean(price)
) %>%
summarise(
SSR = sum( (average_buy_price - price) ^2),
SST = sum( (average_buy_price - mean_price) ^2),
r2 = 1-(SSR/SST)
)
r_2
summary(r_2$r2)
t.test(r_2$r2, mu = 0)
profit <-
sim_optimal %>%
ungroup() %>%
group_by(idx) %>%
filter(TP_bool == TRUE) %>%
summarise(
rp = (sum(realized_profit))
)
profit
profit_r2 <-
left_join(
profit, r_2, by = c("idx")
)
mdl1 <-
lm(
data = profit_r2 %>%
filter(r2>=0),
log(rp) ~ r2
)
summary(mdl1)
emmeans::emmeans(
mdl1,
"r2",
type = "response"
) %>%
broom::tidy()
left_join(
profit, r_2, by = c("idx")
) %>%
ggplot(aes(
(r2), rp*12
)) +
geom_point() +
geom_smooth(method = "lm") +
xlab("R^2") +
ylab("APR") +
scale_y_continuous(labels = scales::percent) +
ggpubr::theme_classic2()
p1 <-
sim_optimal %>%
filter(price != 0, idx %in% c(1:10), average_buy_price != 0) %>%
ggplot(aes(
step, price, group = idx
)) +
geom_line() +
geom_line(aes(step, average_buy_price), color = "blue") +
facet_wrap(~idx)
p1
hist(profit_r2$rp)
profit <-
sim_optimal %>%
ungroup() %>%
group_by(idx) %>%
filter(TP_bool == TRUE) %>%
summarise(
rp = (sum(realized_profit))/10000
)
profit
hist(profit$rp)
mean(profit$rp)
optimization_out
p1 <-
sim_optimal %>%
filter(price != 0, idx %in% c(1:20), average_buy_price != 0) %>%
ggplot(aes(
step, price, group = idx
)) +
geom_line() +
geom_line(aes(step, average_buy_price), color = "blue") +
facet_wrap(~idx)
p1
left_join(
profit, r_2, by = c("idx")
) %>%
ggplot(aes(
(r2), rp*12
)) +
geom_point() +
geom_smooth(method = "lm") +
xlab("R^2") +
ylab("APR") +
scale_y_continuous(labels = scales::percent) +
ggpubr::theme_classic2()
left_join(
profit, r_2, by = c("idx")
) %>%
ggplot(aes(
(r2), rp*12
)) +
geom_point() +
ggpubr::theme_classic2()
left_join(
profit, r_2, by = c("idx")
) %>%
ggplot(aes(
log(r2), rp*12
)) +
geom_point() +
ggpubr::theme_classic2()
left_join(
profit, r_2, by = c("idx")
) %>%
ggplot(aes(
log(r2), log(rp)
)) +
geom_point() +
ggpubr::theme_classic2()
left_join(
profit, r_2, by = c("idx")
) %>%
ggplot(aes(
(r2), log(rp)
)) +
geom_point() +
ggpubr::theme_classic2()
p1 <-
sim_optimal %>%
filter(price != 0, idx %in% c(1:20), average_buy_price != 0) %>%
ggplot(aes(
step, price, group = idx
)) +
geom_line() +
geom_line(aes(step, average_buy_price), color = "blue") +
facet_wrap(~idx)
p1
profit
