price_series = X,
base_order_size = 10000*optimization_out$solution[1],
DCA_order_size = 10000*optimization_out$solution[2],
num_of_dca = 1,
dca_multiplier = optimization_out$solution[3],
price_deviation_target = optimization_out$solution[4],
price_deviation_multiplier = optimization_out$solution[5],
take_profit_target = optimization_out$solution[6],
days = 30,
len = 30*144
) %>% mutate(idx = idx)}, .progress = TRUE)
sim_optimal %>%
group_by(idx) %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
cost = -(profit * n())
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
cost = -(profit * n())
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
cost = -(profit * n())
) %>%
mutate(
mean_cost = mean(cost),
max_dd = min(drawdown)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
cost = -(profit * n()),
max_dd = min(drawdown)
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>% view
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>% view
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
cost = -(profit * n()),
max_dd = min(drawdown)
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
max_dd = min(drawdown),
cost = -(profit * n())
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
filter(price != 0, idx %in% c(1:10), average_buy_price != 0) %>%
ggplot(aes(
step, price, group = idx
)) +
geom_line() +
geom_line(aes(step, average_buy_price), color = "blue") +
facet_wrap(~idx)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
max_dd = min(drawdown),
cost = -(profit/abs(max_dd) * n())
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
max_dd = min(drawdown),
cost = -(profit * n())
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
max_dd = min(drawdown),
cost = -( (profit - abs(max_dd)*profit) )* n()
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
max_dd = min(drawdown),
cost = -( (profit - abs(max_dd)) )* n()
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
max_dd = min(drawdown),
cost = -(profit * n())
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
max_dd = min(drawdown),
cost = -( (profit-10000) * n())
) %>%
mutate(
mean_cost = mean(cost)
)
sim_optimal %>%
group_by(idx) %>%
mutate(
drawdown = (price - average_buy_price) / price
) %>%
drop_na() %>%
filter(TP_bool = TRUE) %>%
summarise(
profit = sum(realized_profit),
max_dd = min(drawdown),
cost = -(( (profit-10000) * n()) * abs(max_dd))
) %>%
mutate(
mean_cost = mean(cost)
)
cost_function <- function(
price_series, # a given simulation
base_order_size,
DCA_order_size,
num_of_dca, # this is the percent of max possible
dca_multiplier, # multiply each successive dca order
price_deviation_target, # when to make a dca order
price_deviation_multiplier,
take_profit_target, # when to take profit
days,
len
){
# initialize parameters
days <- days
len <- 144 * days # to simulate every 10 minutes
price_series <- price_series
capital <- 10000
num_of_dca <- num_of_dca
dca_multiplier <- dca_multiplier
price_deviation_target <- price_deviation_target
take_profit_target <- take_profit_target
dca_counter <- 0
dca_orders_max <- 1
average_buy_price <- 0
price_deviation <- 0
drawdown <- 0
drawdown_out <- 0
# simulation parameters
coin_bag <- c(0) # stores bought coins
buy_prices <- c(0) # stores coin buy prices
outflow <- c(0) # stores money spent
realized_profit <- c(0) # stores realized profit
DCA_bool <- FALSE # bool to store event
TP_bool <- FALSE # bool to store event
# create tibble to store simulation variables
headers <- tibble(
price = 0,
TP_bool = FALSE,
DCA_bool = FALSE,
dca_orders_max = 0,
coin_bag = 0,
buy_prices = 0,
outflow = 0,
average_buy_price = 0,
realized_profit = 0,
price_deviation = 0,
dca_counter = 0,
price_deviation_target = price_deviation_target,
step = 0
)
# main simulation loop
for (i in 1:len){
# observe current price
price <- price_series$y[i]
drawdown <- append(drawdown, if_else(average_buy_price != 0,
(price - average_buy_price) / price,
0))
# update headers
headers <-
headers %>%
add_row(
price = price,
TP_bool = TP_bool,
DCA_bool = DCA_bool,
dca_orders_max = dca_orders_max,
coin_bag = tail(coin_bag, n=1),
buy_prices = tail(buy_prices, n=1),
outflow = tail(outflow, n=1),
average_buy_price = tail(average_buy_price, n=1),
realized_profit = tail(realized_profit, n=1),
price_deviation = price_deviation,
dca_counter = dca_counter,
price_deviation_target = price_deviation_target,
step = i
)
# reset events
DCA_bool <- FALSE
TP_bool <- FALSE
# this is the first buy event
if (i == 1){
# check maximum number of DCA orders
dca_sizes <- (DCA_order_size * (dca_multiplier^(0:100)))
dca_depth <- cumsum(DCA_order_size * (dca_multiplier^(0:100)))
available_dca_capital <- capital - base_order_size
max_depth <- max(which(available_dca_capital >= dca_depth))
dca_orders_max <- trunc(max_depth * num_of_dca)
coin_bag <- append(coin_bag, base_order_size/price)
buy_prices <- append(buy_prices, price)
outflow <- append(outflow, base_order_size)
average_buy_price <- sum(outflow)/sum(coin_bag)
}
# compute actual price deviation from previous order
price_deviation <- (price - tail(buy_prices, n=1)) / price
# make dca order?
if (price_deviation <= price_deviation_target &
dca_counter <= dca_orders_max){
dca_counter <- dca_counter + 1
price_deviation_target <- price_deviation_target *
(price_deviation_multiplier^dca_counter)
DCA_bool <- TRUE
coin_bag <- append(coin_bag, dca_sizes[dca_counter]/price)
buy_prices <- append(buy_prices, price)
outflow <- append(outflow, dca_sizes[dca_counter])
average_buy_price <- sum(outflow)/sum(coin_bag)
}
# take profit
else if ( (price - average_buy_price)/price >= take_profit_target &
i > 1) {
dca_counter <- 0
TP_bool <- TRUE
drawdown_out <- append(drawdown_out, min(drawdown))
drawdown <- 0
realized_profit <- append(realized_profit,
(sum(coin_bag)*price) - sum(outflow)
)
# reset all values
coin_bag <- c()
buy_price <- c()
outflow <- c()
average_buy_price <- 0
# buy ASAP
coin_bag <- append(coin_bag, base_order_size/price)
buy_prices <- append(buy_prices, price)
outflow <- append(outflow, base_order_size)
average_buy_price <- sum(outflow)/sum(coin_bag)
}
# sell all at the end of simulation
if (i == len){
realized_profit <- append(realized_profit,
(sum(coin_bag)*price) - sum(outflow)
)
TP_bool <- TRUE
drawdown_out <- append(drawdown_out, min(drawdown))
drawdown <- 0
# reset all values
coin_bag <- c()
buy_price <- c()
outflow <- c()
average_buy_price <- 0
# update tibble for the last time
headers <-
headers %>%
add_row(
price = price,
TP_bool = TP_bool,
DCA_bool = DCA_bool,
dca_orders_max = dca_orders_max,
coin_bag = tail(coin_bag, n=1),
buy_prices = tail(buy_prices, n=1),
outflow = tail(outflow, n=1),
average_buy_price = tail(average_buy_price, n=1),
realized_profit = tail(realized_profit, n=1),
price_deviation = price_deviation,
dca_counter = dca_counter,
price_deviation_target = price_deviation_target,
step = i
)
# compute end of simulation results
profit_out <- headers %>%
filter(TP_bool == TRUE) %>%
pull(realized_profit) %>%
{sum(.)}
number_of_tp_actions <-
headers %>%
filter(TP_bool == TRUE) %>%
pull(TP_bool) %>%
{length(.)}
uvc <- abs(mean(drawdown_out)) + (sd(drawdown_out)*1)
cost <- -( (profit_out-10000) * number_of_tp_actions)
}
# if (i %% 100 == 0){
#     print(paste0("progress: ", round((i/len)*100,2), "%" ))
#     }
}
# the lower the better
return(cost)
}
list_of_runs <-
runs %>%
group_by(iteration) %>%
group_split()
sample_runs <-
list_of_runs %>%
{.[sample(c(1:length(list_of_runs)), size = 3, replace = FALSE)]}
plan(multisession, workers = 8)
sum_cost_function <- function(
theta
){
out <-
# note: this runs are hardcoded, change this in the future
sample_runs %>%
future_imap_dfr(
., function(X, idx){
print(paste0("Simulating run: ", idx))
cost_sim <- cost_function(
price_series = X,
base_order_size = 10000*theta[1],
DCA_order_size = 10000*theta[2],
num_of_dca = 1,
dca_multiplier = theta[3],
price_deviation_target = theta[4],
price_deviation_multiplier = theta[5],
take_profit_target = theta[6],
days = 30,
len = 30*144
)
print("Simulation over")
return(
tibble(
cost = cost_sim,
idx = idx,
intercept = unique(X$intercept),
poly_1 = unique(X$poly_1),
poly_2 = unique(X$poly_2),
poly_3 = unique(X$poly_3),
mdl_sigma = unique(X$mdl_sigma)
)
)
}
)
return(mean(out$cost))
}
sum_cost_function <- function(
theta
){
out <-
# note: this runs are hardcoded, change this in the future
sample_runs %>%
future_imap_dfr(
., function(X, idx){
print(paste0("Simulating run: ", idx))
cost_sim <- cost_function(
price_series = X,
base_order_size = 10000*theta[1],
DCA_order_size = 10000*theta[2],
num_of_dca = 1,
dca_multiplier = theta[3],
price_deviation_target = theta[4],
price_deviation_multiplier = theta[5],
take_profit_target = theta[6],
days = 30,
len = 30*144
)
print("Simulation over")
return(
tibble(
cost = cost_sim,
idx = idx,
intercept = unique(X$intercept),
poly_1 = unique(X$poly_1),
poly_2 = unique(X$poly_2),
poly_3 = unique(X$poly_3),
mdl_sigma = unique(X$mdl_sigma)
)
)
}
)
return(max(out$cost))
}
opts <- list(
"algorithm" = "NLOPT_LN_BOBYQA",
"xtol_rel" = 1.0e-04,
"maxeval" = 5000000,
"print_level" = 3
)
print(paste0("Starting optimization for: ", coin))
non_linear_opt0 <-
nloptr(
x0 = c(
0.01, # base order size
0.01, # DCA order size
1, # dca multiplier
-0.01, # price_deviation_target
1, # price deviation multiplier
0.05 # take profit target
),
eval_f = sum_cost_function,
lb = c(0.01, 0.01, 1, -0.1, 1, 0.05),
ub = c(0.25, 0.25, 3, -0.005, 3, 0.1),
opts = opts
)
sim_optimal %>%
filter(price != 0, idx %in% c(1:10), average_buy_price != 0) %>%
ggplot(aes(
step, price, group = idx
)) +
geom_line() +
geom_line(aes(step, average_buy_price), color = "blue") +
facet_wrap(~idx)
sim_optimal
write_csv("data/simulation_with_optimal_parameters.csv")
